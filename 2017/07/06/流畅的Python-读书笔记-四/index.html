<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本周的学习计划有可迭代的对象、迭代器和生成器、上下文管理器和else块、协程、使用期物处理并发和使用asyncio包处理并发。下面将分享我的阅读笔记。 迭代器模式指的是按需一次获取一个数据项。在Python中，所有集合都可以迭代，迭代器有以下用途：  for循环 构建和扩展集合类型 逐行遍历文本文件 列表推导、字典推导和集合推导 元组拆包 调用函数时，使用*拆包实参  下面实现一个Sentence">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python-读书笔记(四)">
<meta property="og:url" content="http://yoursite.com/2017/07/06/流畅的Python-读书笔记-四/index.html">
<meta property="og:site_name" content="彼得的博客">
<meta property="og:description" content="本周的学习计划有可迭代的对象、迭代器和生成器、上下文管理器和else块、协程、使用期物处理并发和使用asyncio包处理并发。下面将分享我的阅读笔记。 迭代器模式指的是按需一次获取一个数据项。在Python中，所有集合都可以迭代，迭代器有以下用途：  for循环 构建和扩展集合类型 逐行遍历文本文件 列表推导、字典推导和集合推导 元组拆包 调用函数时，使用*拆包实参  下面实现一个Sentence">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-07-11T03:22:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="流畅的Python-读书笔记(四)">
<meta name="twitter:description" content="本周的学习计划有可迭代的对象、迭代器和生成器、上下文管理器和else块、协程、使用期物处理并发和使用asyncio包处理并发。下面将分享我的阅读笔记。 迭代器模式指的是按需一次获取一个数据项。在Python中，所有集合都可以迭代，迭代器有以下用途：  for循环 构建和扩展集合类型 逐行遍历文本文件 列表推导、字典推导和集合推导 元组拆包 调用函数时，使用*拆包实参  下面实现一个Sentence">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/06/流畅的Python-读书笔记-四/"/>





  <title>流畅的Python-读书笔记(四) | 彼得的博客</title>
  <link rel="stylesheet" type="text/css" href="/css/prettify.css">
  <link rel="stylesheet" type="text/css" href="/css/github-v2.css">
  <link rel="stylesheet" type="text/css" href="/css/github-v2.min.css">
  <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
       <script type="text/x-mathjax-config">
         MathJax.Hub.Config({
           tex2jax: {
             inlineMath: [ ['$','$'], ["\\(","\\)"] ],
             processEscapes: true
           }
         });
       </script>
       <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">彼得的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/流畅的Python-读书笔记-四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Peter Tsung">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/pandas.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="彼得的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                流畅的Python-读书笔记(四)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T15:12:02+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-Notes/" itemprop="url" rel="index">
                    <span itemprop="name">Python_Notes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本周的学习计划有<code>可迭代的对象、迭代器和生成器</code>、<code>上下文管理器和else块</code>、<code>协程</code>、<code>使用期物处理并发</code>和<code>使用asyncio包处理并发</code>。下面将分享我的阅读笔记。</p>
<p>迭代器模式指的是按需一次获取一个数据项。在Python中，所有集合都可以迭代，迭代器有以下用途：</p>
<ul>
<li>for循环</li>
<li>构建和扩展集合类型</li>
<li>逐行遍历文本文件</li>
<li>列表推导、字典推导和集合推导</li>
<li>元组拆包</li>
<li>调用函数时，使用*拆包实参</li>
</ul>
<p>下面实现一个Sentence类，第1版实现序列协议。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> re
<span class="im">import</span> reprlib

RE_WORD <span class="op">=</span> re.<span class="bu">compile</span>(<span class="st">&#39;\w+&#39;</span>)

<span class="kw">class</span> Sentence:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, text):
        <span class="va">self</span>.text <span class="op">=</span> text
        <span class="co"># re.findall函数返回一个字符串列表，里面的元素是正则表达式的全部非重叠匹配</span>
        <span class="va">self</span>.words <span class="op">=</span> RE_WORD.findall(text)
        
    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, index):
        <span class="co"># self.words中保存的是.findall函数返回的结果，因此直接返回指定索引位上的单词</span>
        <span class="cf">return</span> <span class="va">self</span>.words[index] 
    
    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.words)
    
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="co"># reprlib.repr用于生成大型数据结构的简略字符串表示形式</span>
        <span class="cf">return</span> <span class="st">&#39;Sentence(</span><span class="sc">%s</span><span class="st">)&#39;</span> <span class="op">%</span> reprlib.<span class="bu">repr</span>(<span class="va">self</span>.text)</code></pre></div>
<p>下面我们来测试一下Sentence实例能否迭代。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> s <span class="op">=</span> Sentence(<span class="st">&#39;&quot;The time has come,&quot; the Walrus said,&#39;</span>) <span class="co"># 传入一个字符串，创建一个Sentence实例。</span>
<span class="op">&gt;&gt;&gt;</span> s
Sentence(<span class="st">&#39;&quot;The time ha... Walrus said,&#39;</span>) <span class="co"># 注意，__repr__方法的输出中包含reprlib.repr方法生成</span>
<span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> word <span class="kw">in</span> s: <span class="co"># Sentence实例可以迭代</span>
...     <span class="bu">print</span>(word)
The
time
has
come
the
Walrus
said
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(s) <span class="co"># 因为可以迭代，所以Sentence对象可以用于构建列表和其他可迭代的类型。</span>
[<span class="st">&#39;The&#39;</span>, <span class="st">&#39;time&#39;</span>, <span class="st">&#39;has&#39;</span>, <span class="st">&#39;come&#39;</span>, <span class="st">&#39;the&#39;</span>, <span class="st">&#39;Walrus&#39;</span>, <span class="st">&#39;said&#39;</span>]</code></pre></div>
<p>解释器需要迭代对象x时，会自动调用<code>iter(x)</code>。</p>
<p>内置的<code>iter</code>函数有以下作用。</p>
<ol style="list-style-type: decimal">
<li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获取一个迭代器。</li>
<li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li>
<li>如果尝试失败，Python抛出<code>TypeError</code>异常，通常会提示“C object is not iterable”（C对象不可迭代），其中C是目标对象所属的类。</li>
</ol>
<p>任何Python序列都可迭代的原因是，它们都实现了<code>__getitem__</code>方法。其实，标准的序列也都实现了<code>__iter__</code>方法，之所以对<code>__getitem__</code>方法做特殊处理，是为了向后兼容。</p>
<blockquote>
<p>可迭代的对象</p>
<p>使用<code>iter</code>内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也可以迭代。</p>
</blockquote>
<p>标准的迭代器接口有两个方法。</p>
<p><code>__next__</code></p>
<p>返回下一个可用的元素，如果没有元素了，抛出<code>StopIteration</code>异常。</p>
<p><code>__iter__</code></p>
<p>返回<code>self</code>，以便在应该使用可迭代对象的地方使用迭代器。</p>
<p><code>Iterator</code>抽象基类实现<code>__iter__</code>方法的方式是返回实例本身（<code>return self</code>）。这样在需要可迭代对象的地方可以使用迭代器。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Iterator(Iterable):
    
    __slots__ <span class="op">=</span> ()
    
    <span class="at">@abstractmethod</span>
    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):
        <span class="cf">raise</span> <span class="pp">StopIteration</span>
        
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="va">self</span>
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> __subclasshook__(cls, c):
        <span class="cf">if</span> cls <span class="kw">is</span> Iterator:
            <span class="cf">if</span> (<span class="bu">any</span>(<span class="st">&quot;__next__&quot;</span> <span class="kw">in</span> B.__dict__ <span class="cf">for</span> B <span class="kw">in</span> C.__mro__) <span class="kw">and</span>
                <span class="bu">any</span>(<span class="st">&quot;__iter__&quot;</span> <span class="kw">in</span> B.__dict__ <span class="cf">for</span> B <span class="kw">in</span> C.__mro__)):
                <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">return</span> <span class="va">NotImplemented</span></code></pre></div>
<p>下面给出迭代器的定义。</p>
<blockquote>
<p>迭代器</p>
<p>迭代器是这样的对象：实现了无参数的<code>__next__</code>方法，返回序列中的下一个元素；如果没有元素了，那么抛出<code>StopIteration</code>异常。Python中的迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p>
</blockquote>
<p>Sentence类第2版可以迭代，因为它实现了特殊的<code>__iter__</code>方法，构建并返回一个<code>SentenceIterator</code>实例。而且这一版类可以清楚地说明<strong>可迭代的对象</strong>和<strong>迭代器</strong>之间的重要区别，以及二者之间的联系。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> re
<span class="im">import</span> reprlib

RE_WORD <span class="op">=</span> re.<span class="bu">compile</span>(<span class="st">&#39;\w+&#39;</span>)

<span class="kw">class</span> Sentence:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, text):
        <span class="va">self</span>.text <span class="op">=</span> text
        <span class="va">self</span>.words <span class="op">=</span> RE_WORD.findall(text)
    
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;Sentence(</span><span class="sc">%s</span><span class="st">)&#39;</span> <span class="op">%</span> reprlib.<span class="bu">repr</span>(<span class="va">self</span>.text)
    
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>): <span class="co">#表明这个类可以实现迭代。</span>
        <span class="cf">return</span> SentenceIterator(<span class="va">self</span>.words)<span class="co"># 根据可迭代协议，__iter__方法实例化并返回一个迭代器。</span>
    
<span class="kw">class</span> SentenceIterator:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, words):
        <span class="va">self</span>.words <span class="op">=</span> words <span class="co">#SentenceIterator实例引用单词列表。</span>
        <span class="va">self</span>.index <span class="op">=</span> <span class="dv">0</span> <span class="co">#self.index用于确定下一个要获取的单词。</span>
    
    <span class="kw">def</span> <span class="fu">__next__</span>(<span class="va">self</span>):
        <span class="cf">try</span>:
            word <span class="op">=</span> <span class="va">self</span>.words[<span class="va">self</span>.index] <span class="co"># 获取self.index索引位上的单词</span>
        <span class="cf">except</span> <span class="pp">IndexError</span>:
            <span class="cf">raise</span> <span class="pp">StopIteration</span>() <span class="co"># 如果self.index索引位上没有单词，那么抛出StopIteration异常。</span>
        <span class="va">self</span>.index <span class="op">+=</span> <span class="dv">1</span> <span class="co"># 递增self.index的值</span>
        <span class="cf">return</span> word <span class="co"># 返回单词</span>
    
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>): <span class="co"># 实现self.__iter__方法</span>
        <span class="cf">return</span> <span class="va">self</span></code></pre></div>
<p>可迭代的对象有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而迭代器要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。因此，迭代器可以迭代，但是可迭代的对象不是迭代器。</p>
<blockquote>
<p>迭代器模式可用来</p>
<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示</li>
<li>支持对聚合对象的多种遍历</li>
<li>为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）</li>
</ul>
</blockquote>
<p>为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用<code>iter(my_iterable)</code>都新建一个独立的迭代器。</p>
<p>可迭代的对象一定不能是自身的迭代器。可迭代的对象必须实现<code>__iter__</code>方法，但不能实现<code>__next__</code>方法。</p>
<p>另外，迭代器应该是一直可以迭代。迭代器的<code>__iter__</code>方法应该返回自身。</p>
<p>在第3版的Sentence类中，使用生成器函数来代替SenteceIterator类来以符合Python习惯的方式来实现相同功能。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> re
<span class="im">import</span> reprlib

RE_WORD <span class="op">=</span> re.<span class="bu">compile</span>(<span class="st">&#39;\w+&#39;</span>)

<span class="kw">class</span> Sentence:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, text):
        <span class="va">self</span>.text <span class="op">=</span> text
        <span class="va">self</span>.words <span class="op">=</span> RE_WORD.findall(text)
    
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;Sentence(</span><span class="sc">%s</span><span class="st">)&#39;</span> <span class="op">%</span> reprlib.<span class="bu">repr</span>(<span class="va">self</span>.text)
    
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):
        <span class="cf">for</span> word <span class="kw">in</span> <span class="va">self</span>.words: <span class="co"># 迭代self.words</span>
            <span class="cf">yield</span> word <span class="co"># 产出当前的word。</span>
        <span class="cf">return</span> <span class="co"># 这个return语句不是必要的；这个函数可以直接&quot;落空&quot;，自动返回。不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成完全部值之后会直接退出。</span></code></pre></div>
<p>在本例中，迭代器其实就是生成器对象，每次调用<code>__iter__</code>方法都会自动创建，因为这里的<code>__iter__</code>方法是生成器函数。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> gen_123():<span class="co">#只要Python函数中包含关键字yield，该函数就是生成器函数</span>
...     <span class="cf">yield</span> <span class="dv">1</span> <span class="co">#生成器函数的定义体中通常都有循环，不过这不是必要条件；这里喔重复使用3次yield。</span>
...     <span class="cf">yield</span> <span class="dv">2</span>
...     <span class="cf">yield</span> <span class="dv">3</span>
...
<span class="op">&gt;&gt;&gt;</span> gen_123
<span class="op">&lt;</span>function gen_123 at <span class="bn">0x10a99e400</span><span class="op">&gt;</span> <span class="co">#gen_123是函数对象</span>
<span class="op">&gt;&gt;&gt;</span> gen_123()
<span class="op">&lt;</span>generator <span class="bu">object</span> gen_123 at <span class="bn">0x10a999830</span><span class="op">&gt;</span> <span class="co">#但是调用时，gen_123()返回一个生成器对象。</span>
<span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> i <span class="kw">in</span> gen_123(): <span class="co"># 生成器是迭代器，会生成传给yield关键字的表达式的值。</span>
...     <span class="bu">print</span>(i)
...
<span class="dv">1</span>
<span class="dv">2</span>
<span class="dv">3</span>
<span class="op">&gt;&gt;&gt;</span> g <span class="op">=</span> gen_123() 
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g) <span class="co"># 因为g是迭代器，所以调用next(g)会获取yield生成的下一个元素</span>
<span class="dv">1</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g)
<span class="dv">2</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g)
<span class="dv">3</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g)
Traceback (most recent call last):
  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span>
<span class="pp">StopIteration</span></code></pre></div>
<p><code>re.finditer</code>函数是<code>re.findall</code>函数的惰性版本，返回的不是列表，而是一个生成器，按需生成<code>re.MatchObject</code>实例。如果有很多匹配，<code>re.findall</code>函数能节省大量内存。所以如下第4版Sentence类会只在需要时才生成下一个单词。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> re
<span class="im">import</span> reprlib

RE_WORD <span class="op">=</span> re.<span class="bu">compile</span>(<span class="st">&#39;\w+&#39;</span>)

<span class="kw">class</span> Sentence:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, text):
        <span class="va">self</span>.text <span class="op">=</span> text <span class="co"># 不再需要words列表</span>
        
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;Sentence(</span><span class="sc">%s</span><span class="st">)&#39;</span> <span class="op">%</span> reprlib.<span class="bu">repr</span>(<span class="va">self</span>.text)
    
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):
        <span class="cf">for</span> match <span class="kw">in</span> RE_WORD.finditer(<span class="va">self</span>.text): <span class="co"># finditer函数构建一个迭代器，包含self.text中匹配RE_WORD的单词，产出MatchObject实例。</span>
            <span class="cf">yield</span> match.group() <span class="co"># match.group()方法从MatchObject实例中提取匹配正则表达式的具体文本</span></code></pre></div>
<p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。如果列表推导是制造列表的工厂，那么生成器表达式就是制造生成器的工厂。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> gen_AB(): 
...     <span class="bu">print</span>(<span class="st">&#39;start&#39;</span>)
...     <span class="cf">yield</span> <span class="st">&#39;A&#39;</span>
...     <span class="bu">print</span>(<span class="st">&#39;continue&#39;</span>)
...     <span class="cf">yield</span> <span class="st">&#39;B&#39;</span>
...     <span class="bu">print</span>(<span class="st">&#39;end.&#39;</span>)
...
<span class="op">&gt;&gt;&gt;</span> res1 <span class="op">=</span> [x<span class="op">*</span><span class="dv">3</span> <span class="cf">for</span> x <span class="kw">in</span> gen_AB()] <span class="co"># 列表推导迫切地迭代gen_AB()函数生成的生成器对象产出的元素：’A‘和’B‘。</span>
start
<span class="cf">continue</span>
end.
<span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> i <span class="kw">in</span> res1: <span class="co"># 这个for循环迭代列表推导生成的res1列表。</span>
...     <span class="bu">print</span>(<span class="st">&#39;--&gt;&#39;</span>, i)
...
<span class="op">--&gt;</span> AAA
<span class="op">--&gt;</span> BBB
<span class="op">&gt;&gt;&gt;</span> res2 <span class="op">=</span> (x<span class="op">*</span><span class="dv">3</span> <span class="cf">for</span> x <span class="kw">in</span> gen_AB()) <span class="co"># 把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。</span>
<span class="op">&gt;&gt;&gt;</span> res2 <span class="co"># res2是一个生成器对象</span>
<span class="op">&lt;</span>generator <span class="bu">object</span> <span class="op">&lt;</span>genexpr<span class="op">&gt;</span> at <span class="bn">0x109691888</span><span class="op">&gt;</span>
<span class="co"># 只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。</span>
<span class="co"># for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。</span>
<span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> i <span class="kw">in</span> res2: 
...     <span class="bu">print</span>(<span class="st">&#39;--&gt;&#39;</span>, i)
...
start
<span class="op">--&gt;</span> AAA
<span class="cf">continue</span>
<span class="op">--&gt;</span> BBB
end.</code></pre></div>
<p>因此可以看出，生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少Sentence类的代码。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> re
<span class="im">import</span> reprlib

RE_WORD <span class="op">=</span> re.<span class="bu">compile</span>(<span class="st">&#39;\w+&#39;</span>)

<span class="kw">class</span> Sentence:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, text):
        <span class="va">self</span>.text <span class="op">=</span> text
        
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;Sentence(</span><span class="sc">%s</span><span class="st">)&#39;</span> <span class="op">%</span> reprlib.<span class="bu">repr</span>(<span class="va">self</span>.text)
    
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):
        <span class="cf">return</span> (match.group() <span class="cf">for</span> match <span class="kw">in</span> RE_WORD.finditer(<span class="va">self</span>.text))</code></pre></div>
<p>在<code>__iter__</code>方法中，已经不是生成器函数（没有<code>yield</code>），而是使用生成器表达式构建生成器，然后将其返回。最终的效果一样：调用<code>__iter__</code>方法会得到一个生成器对象。</p>
<p>生成器表达式是语法糖：完全可以替换成生成器函数。</p>
<p>下面实现等差数列。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> ArithmeticProgression:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, begin, step, end<span class="op">=</span><span class="va">None</span>): <span class="co">#__init__方法需要两个参数：begin和step。end是可选的，如果值是None，那么生成的是无穷数列。</span>
        <span class="va">self</span>.begin <span class="op">=</span> begin
        <span class="va">self</span>.step <span class="op">=</span> step
        <span class="va">self</span>.end <span class="op">=</span> end
        
    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):
        result <span class="op">=</span> <span class="bu">type</span>(<span class="va">self</span>.begin <span class="op">+</span> <span class="va">self</span>.step)(<span class="va">self</span>.begin) <span class="co"># 把self.begin赋值给result，不过会先强制转换成前面的加法算式得到的类型。</span>
        forever <span class="op">=</span> <span class="va">self</span>.end <span class="kw">is</span> <span class="va">None</span>
        index <span class="op">=</span> <span class="dv">0</span>
        <span class="cf">while</span> forever <span class="kw">or</span> result <span class="op">&lt;</span> <span class="va">self</span>.end:
            <span class="cf">yield</span> result
            index <span class="op">+=</span> <span class="dv">1</span>
            result <span class="op">=</span> <span class="va">self</span>.begin <span class="op">+</span> <span class="va">self</span>.step <span class="op">*</span> index</code></pre></div>
<p>下面的例子是生成器函数，实现同样的功能，但是代码量更少。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> aritprog_gen(begin, step, end<span class="op">=</span><span class="va">None</span>):
    result <span class="op">=</span> <span class="bu">type</span>(begin <span class="op">+</span> step)(begin)
    forever <span class="op">=</span> end <span class="kw">is</span> <span class="va">None</span>
    index <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">while</span> forever <span class="kw">or</span> result <span class="op">&lt;</span> end:
        <span class="cf">yield</span> result
        index <span class="op">+=</span> <span class="dv">1</span>
        result <span class="op">=</span> begin <span class="op">+</span> step <span class="op">*</span> index</code></pre></div>
<p>下面使用<code>itertools</code>模块生成等差数列。</p>
<p><code>itertools.count</code>函数返回的生成器能生成多个数，<code>itertools.takewhile</code>函数会生成一个使用另一个生成器的生成器，在指定的条件计算结果为False时停止。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> itertools

<span class="kw">def</span> aritprog_gen(begin, step, end<span class="op">=</span><span class="va">None</span>):
    first <span class="op">=</span> <span class="bu">type</span>(begin <span class="op">+</span> step)(begin)
    ap_gen <span class="op">=</span> itertools.count(first, step)
    <span class="cf">if</span> end <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
        ap_gen <span class="op">=</span> itertools.takewhile(<span class="kw">lambda</span> n: n <span class="op">&lt;</span> end, ap_gen)
    <span class="cf">return</span> ap_gen</code></pre></div>
<p>下面介绍Python标准库中的生成器函数。</p>
<p>第一组是<u>用于过滤</u>的生成器函数：从输入的可迭代对象中产出元素的子集，而且不修改元素本身。</p>
<table>
<colgroup>
<col width="10%">
<col width="44%">
<col width="44%">
</colgroup>
<thead>
<tr class="header">
<th align="center">模块</th>
<th align="left">函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">itertools</td>
<td align="left">compress(it, selector_it)</td>
<td>并行处理两个可迭代的对象；如果selector_it中的元素是真值，产出it中对应的元素</td>
</tr>
<tr class="even">
<td align="center">itertools</td>
<td align="left">dropwhile(predicate, it)</td>
<td>处理it，跳过predicate的计算结果为真值的元素，然后产出剩下的各个元素（不再进一步检查）</td>
</tr>
<tr class="odd">
<td align="center">（内置）</td>
<td align="left">filter(predicate, it)</td>
<td>把it中的各个元素传给predicate，如果predicate(item)返回真值，那么产出对应的元素；如果predicate是None，那么只产出真值元素</td>
</tr>
<tr class="even">
<td align="center">itertools</td>
<td align="left">filterfalse(predicate, it)</td>
<td>与filter函数的作用类似，不过predicate的逻辑是相反的：predicate返回假值时产出对应的元素</td>
</tr>
<tr class="odd">
<td align="center">itertools</td>
<td align="left">islice(it, stop) 或 islice(it, start, stop, step=1)</td>
<td>产出it的切片，实现的是惰性操作</td>
</tr>
<tr class="even">
<td align="center">itertools</td>
<td align="left">takewhile(predicate, it)</td>
<td>predicate返回真值时产出对应的元素，然后立即停止，不再继续检查</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> vowel(c):
...     <span class="cf">return</span> c.lower() <span class="kw">in</span> <span class="st">&#39;aeiou&#39;</span>
...
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">filter</span>(vowel, <span class="st">&#39;Aardvark&#39;</span>))
[<span class="st">&#39;A&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> itertools
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.filterfalse(vowel, <span class="st">&#39;Aardvark&#39;</span>))
[<span class="st">&#39;r&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;v&#39;</span>, <span class="st">&#39;r&#39;</span>, <span class="st">&#39;k&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.dropwhile(vowel, <span class="st">&#39;Aardvark&#39;</span>))
[<span class="st">&#39;r&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;v&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;r&#39;</span>, <span class="st">&#39;k&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.takewhile(vowel, <span class="st">&#39;Aardvark&#39;</span>))
[<span class="st">&#39;A&#39;</span>, <span class="st">&#39;a&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.compress(<span class="st">&#39;Aardvark&#39;</span>, (<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)))
[<span class="st">&#39;A&#39;</span>, <span class="st">&#39;r&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;a&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.islice(<span class="st">&#39;Aardvark&#39;</span>, <span class="dv">4</span>))
[<span class="st">&#39;A&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;r&#39;</span>, <span class="st">&#39;d&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.islice(<span class="st">&#39;Aardvark&#39;</span>, <span class="dv">4</span>, <span class="dv">7</span>))
[<span class="st">&#39;v&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;r&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.islice(<span class="st">&#39;Aardvark&#39;</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">2</span>))
[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;a&#39;</span>]</code></pre></div>
<p>下一组是<u>用于映射</u>的生成器函数：在输入的单个可迭代对象（map和starmap函数处理多个可迭代的对象）中的各个元素上做计算，然后返回结果。</p>
<table>
<colgroup>
<col width="12%">
<col width="37%">
<col width="50%">
</colgroup>
<thead>
<tr class="header">
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>itertools</td>
<td>accumulate(it, [func])</td>
<td>产出累计的总和；如果提供了func，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果</td>
</tr>
<tr class="even">
<td>（内置）</td>
<td>enumerate(iterable, start=0)</td>
<td>产出由两个元素组成的元组，结构是(index, item)，其中index从start开始计数，item则从iterable中获取</td>
</tr>
<tr class="odd">
<td>（内置）</td>
<td>map(func, it1, [it2, …, itN])</td>
<td>把it中的各个元素传给func，产出结果；如果传入N个可迭代的对象，那么func必须能接受N个参数，而且要并行处理各个可迭代的对象</td>
</tr>
<tr class="even">
<td>itertools</td>
<td>starmap(func, it)</td>
<td>把it中的各个元素传给func， 产出结果；输入的可迭代对象应该产出可迭代的元素iit，然后以func(*iit)这种形式调用func</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> sample <span class="op">=</span> [<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> itertools
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.accumulate(sample))
[<span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">18</span>, <span class="dv">25</span>, <span class="dv">33</span>, <span class="dv">41</span>, <span class="dv">45</span>, <span class="dv">48</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">52</span>, <span class="dv">54</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.accumulate(sample, <span class="bu">min</span>))
[<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.accumulate(sample, <span class="bu">max</span>))
[<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> operator
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.accumulate(sample, operator.mul))
[<span class="dv">5</span>, <span class="dv">20</span>, <span class="dv">60</span>, <span class="dv">360</span>, <span class="dv">2520</span>, <span class="dv">20160</span>, <span class="dv">161280</span>, <span class="dv">645120</span>, <span class="dv">1935360</span>, <span class="dv">5806080</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.accumulate(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>), operator.mul))
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">24</span>, <span class="dv">120</span>, <span class="dv">720</span>, <span class="dv">5040</span>, <span class="dv">40320</span>, <span class="dv">362880</span>, <span class="dv">3628800</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">enumerate</span>(<span class="st">&#39;albatroz&#39;</span>, <span class="dv">1</span>))
[(<span class="dv">1</span>, <span class="st">&#39;a&#39;</span>), (<span class="dv">2</span>, <span class="st">&#39;l&#39;</span>), (<span class="dv">3</span>, <span class="st">&#39;b&#39;</span>), (<span class="dv">4</span>, <span class="st">&#39;a&#39;</span>), (<span class="dv">5</span>, <span class="st">&#39;t&#39;</span>), (<span class="dv">6</span>, <span class="st">&#39;r&#39;</span>), (<span class="dv">7</span>, <span class="st">&#39;o&#39;</span>), (<span class="dv">8</span>, <span class="st">&#39;z&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(operator.mul, <span class="bu">range</span>(<span class="dv">11</span>), <span class="bu">range</span>(<span class="dv">11</span>)))
[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">9</span>, <span class="dv">16</span>, <span class="dv">25</span>, <span class="dv">36</span>, <span class="dv">49</span>, <span class="dv">64</span>, <span class="dv">81</span>, <span class="dv">100</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(operator.mul, <span class="bu">range</span>(<span class="dv">11</span>), [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">8</span>]))
[<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">16</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> a, b: (a, b), <span class="bu">range</span>(<span class="dv">11</span>), [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">8</span>]))
[(<span class="dv">0</span>, <span class="dv">2</span>), (<span class="dv">1</span>, <span class="dv">4</span>), (<span class="dv">2</span>, <span class="dv">8</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> itertools
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.starmap(operator.mul, <span class="bu">enumerate</span>(<span class="st">&#39;albatroz&#39;</span>, <span class="dv">1</span>)))
[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;ll&#39;</span>, <span class="st">&#39;bbb&#39;</span>, <span class="st">&#39;aaaa&#39;</span>, <span class="st">&#39;ttttt&#39;</span>, <span class="st">&#39;rrrrrr&#39;</span>, <span class="st">&#39;ooooooo&#39;</span>, <span class="st">&#39;zzzzzzzz&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.starmap(<span class="kw">lambda</span> a, b: b<span class="op">/</span>a,
...     <span class="bu">enumerate</span>(itertools.accumulate(sample), <span class="dv">1</span>)))
[<span class="fl">5.0</span>, <span class="fl">4.5</span>, <span class="fl">4.0</span>, <span class="fl">4.5</span>, <span class="fl">5.0</span>, <span class="fl">5.5</span>, <span class="fl">5.857142857142857</span>, <span class="fl">5.625</span>, <span class="fl">5.333333333333333</span>, <span class="fl">5.1</span>, <span class="fl">4.636363636363637</span>, <span class="fl">4.333333333333333</span>, <span class="fl">4.153846153846154</span>]</code></pre></div>
<p>下面是<u>用于合并</u>的生成器函数，这些函数都从输入的多个可迭代对象中产出元素。</p>
<table>
<colgroup>
<col width="10%">
<col width="44%">
<col width="44%">
</colgroup>
<thead>
<tr class="header">
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>itertools</td>
<td>chain(it1, …, itN)</td>
<td>先产出it1中的所有元素，然后产出it2中的所有元素，以此类推，无缝连接在一起</td>
</tr>
<tr class="even">
<td>itertools</td>
<td>chain.from_iterable(it)</td>
<td>产出it生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；it应该产出可迭代的元素，例如可迭代的对象列表</td>
</tr>
<tr class="odd">
<td>itertools</td>
<td>product(it1, …, itN, repeat=1)</td>
<td>计算笛卡尔积：从输入的各个可迭代对象中获取元素，合并成由N个元素组成的元组，与嵌套的for循环效果一样；repeat指明重复处理多少次输入的可迭代对象</td>
</tr>
<tr class="even">
<td>（内置）</td>
<td>zip(it1, …, itN)</td>
<td>并行从输入的各个可迭代对象中获取元素，产出由N个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止</td>
</tr>
<tr class="odd">
<td>itertools</td>
<td>zip_longest(it1, …, itN, fillvalue=None)</td>
<td>并行从输入的各个可迭代对象中获取元素，产出由N个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用fillvalue填充</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.chain(<span class="st">&#39;ABC&#39;</span>, <span class="bu">range</span>(<span class="dv">2</span>)))
[<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="dv">0</span>, <span class="dv">1</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.chain(<span class="bu">enumerate</span>(<span class="st">&#39;ABC&#39;</span>)))
[(<span class="dv">0</span>, <span class="st">&#39;A&#39;</span>), (<span class="dv">1</span>, <span class="st">&#39;B&#39;</span>), (<span class="dv">2</span>, <span class="st">&#39;C&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.chain.from_iterable(<span class="bu">enumerate</span>(<span class="st">&#39;ABC&#39;</span>)))
[<span class="dv">0</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">2</span>, <span class="st">&#39;C&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">zip</span>(<span class="st">&#39;ABC&#39;</span>, <span class="bu">range</span>(<span class="dv">5</span>)))
[(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>), (<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;C&#39;</span>, <span class="dv">2</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">zip</span>(<span class="st">&#39;ABC&#39;</span>, <span class="bu">range</span>(<span class="dv">5</span>), [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>]))
[(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>, <span class="dv">10</span>), (<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>, <span class="dv">20</span>), (<span class="st">&#39;C&#39;</span>, <span class="dv">2</span>, <span class="dv">30</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.zip_longest(<span class="st">&#39;ABC&#39;</span>, <span class="bu">range</span>(<span class="dv">5</span>)))
[(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>), (<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;C&#39;</span>, <span class="dv">2</span>), (<span class="va">None</span>, <span class="dv">3</span>), (<span class="va">None</span>, <span class="dv">4</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.zip_longest(<span class="st">&#39;ABC&#39;</span>, <span class="bu">range</span>(<span class="dv">5</span>), fillvalue<span class="op">=</span><span class="st">&#39;?&#39;</span>))
[(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>), (<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;C&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;?&#39;</span>, <span class="dv">3</span>), (<span class="st">&#39;?&#39;</span>, <span class="dv">4</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.product(<span class="st">&#39;ABC&#39;</span>, <span class="bu">range</span>(<span class="dv">2</span>)))
[(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>), (<span class="st">&#39;A&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;B&#39;</span>, <span class="dv">0</span>), (<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;C&#39;</span>, <span class="dv">0</span>), (<span class="st">&#39;C&#39;</span>, <span class="dv">1</span>)]
<span class="op">&gt;&gt;&gt;</span> suits <span class="op">=</span> <span class="st">&#39;spades hearts diamonds clubs&#39;</span>.split()
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.product(<span class="st">&#39;AK&#39;</span>, suits))
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;spades&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;hearts&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;diamonds&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;clubs&#39;</span>), (<span class="st">&#39;K&#39;</span>, <span class="st">&#39;spades&#39;</span>), (<span class="st">&#39;K&#39;</span>, <span class="st">&#39;hearts&#39;</span>), (<span class="st">&#39;K&#39;</span>, <span class="st">&#39;diamonds&#39;</span>), (<span class="st">&#39;K&#39;</span>, <span class="st">&#39;clubs&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.product(<span class="st">&#39;ABC&#39;</span>))
[(<span class="st">&#39;A&#39;</span>,), (<span class="st">&#39;B&#39;</span>,), (<span class="st">&#39;C&#39;</span>,)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.product(<span class="st">&#39;ABC&#39;</span>, repeat<span class="op">=</span><span class="dv">2</span>))
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;C&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.product(<span class="bu">range</span>(<span class="dv">2</span>), repeat<span class="op">=</span><span class="dv">3</span>)
...
... )
[(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)]
<span class="op">&gt;&gt;&gt;</span> rows <span class="op">=</span> itertools.product(<span class="st">&#39;AB&#39;</span>, <span class="bu">range</span>(<span class="dv">2</span>), repeat<span class="op">=</span><span class="dv">2</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> row <span class="kw">in</span> rows: <span class="bu">print</span>(row)
...
(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;A&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">0</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;A&#39;</span>, <span class="dv">1</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">0</span>)
(<span class="st">&#39;B&#39;</span>, <span class="dv">1</span>, <span class="st">&#39;B&#39;</span>, <span class="dv">1</span>)</code></pre></div>
<p>有些生成器函数会从一个元素中产出多个值，扩展输入的可迭代对象。</p>
<table>
<colgroup>
<col width="10%">
<col width="44%">
<col width="44%">
</colgroup>
<thead>
<tr class="header">
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>itertools</td>
<td>combination(it, out_len)</td>
<td>把it产出的out_len个元素组合在一起，然后产出</td>
</tr>
<tr class="even">
<td>itertools</td>
<td>combinations_with_replacement(it, out_len)</td>
<td>把it产出的out_len个元素组合在一起，然后产出，包含相同元素的组合</td>
</tr>
<tr class="odd">
<td>itertools</td>
<td>count(start=0, step=1)</td>
<td>从start开始不断产出数字，按step指定的步幅增加</td>
</tr>
<tr class="even">
<td>itertools</td>
<td>cycle(it)</td>
<td>从it中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</td>
</tr>
<tr class="odd">
<td>itertools</td>
<td>permutations(it, out_len=None)</td>
<td>把out_len个it产出的元素排列在一起，然后产出这些排列；out_len的默认值等于len(list(it))</td>
</tr>
<tr class="even">
<td>itertools</td>
<td>repeat(item, [times])</td>
<td>重复不断地产出指定的元素，除非提供times，指定次数</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> ct <span class="op">=</span> itertools.count()
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(ct)
<span class="dv">0</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(ct), <span class="bu">next</span>(ct), <span class="bu">next</span>(ct)
(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.islice(itertools.count(<span class="dv">1</span>, .<span class="dv">3</span>), <span class="dv">3</span>))
[<span class="dv">1</span>, <span class="fl">1.3</span>, <span class="fl">1.6</span>]
<span class="op">&gt;&gt;&gt;</span> cy <span class="op">=</span> itertools.cycle(<span class="st">&#39;ABC&#39;</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(cy)
<span class="co">&#39;A&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.islice(cy, <span class="dv">7</span>))
[<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> rp <span class="op">=</span> itertools.repeat(<span class="dv">7</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(rp), <span class="bu">next</span>(rp)
(<span class="dv">7</span>, <span class="dv">7</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.repeat(<span class="dv">8</span>, <span class="dv">4</span>))
[<span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">8</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(operator.mul, <span class="bu">range</span>(<span class="dv">11</span>), itertools.repeat(<span class="dv">5</span>)))
[<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">25</span>, <span class="dv">30</span>, <span class="dv">35</span>, <span class="dv">40</span>, <span class="dv">45</span>, <span class="dv">50</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.combinations(<span class="st">&#39;ABC&#39;</span>, <span class="dv">2</span>))
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.combinations_with_replacement(<span class="st">&#39;ABC&#39;</span>, <span class="dv">2</span>))
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;C&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.permutations(<span class="st">&#39;ABC&#39;</span>, <span class="dv">2</span>))
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;B&#39;</span>)]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.product(<span class="st">&#39;ABC&#39;</span>, repeat<span class="op">=</span><span class="dv">2</span>))
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;C&#39;</span>)]</code></pre></div>
<p>下面是<u>用于重新排列</u>元素的生成器函数</p>
<table>
<colgroup>
<col width="13%">
<col width="30%">
<col width="56%">
</colgroup>
<thead>
<tr class="header">
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>itertools</td>
<td>groupby(it, key=None)</td>
<td>产出由两个元素组成的元素，形式为(key, group)，其中key是分组标准，group是生成器，用于产出分组里的元素</td>
</tr>
<tr class="even">
<td>(内置)</td>
<td>reversed(seq)</td>
<td>从后向前，倒序产出seq中的元素；seq必须是序列，或者是实现了__reversed__特殊方法的对象</td>
</tr>
<tr class="odd">
<td>itertools</td>
<td>tee(it, n=2)</td>
<td>产出一个由n个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> char, group <span class="kw">in</span> itertools.groupby(<span class="st">&#39;LLLLLAAAAGGG&#39;</span>):
...     <span class="bu">print</span>(char, <span class="st">&#39;-&gt;&#39;</span>, <span class="bu">list</span>(group))
...
L <span class="op">-&gt;</span> [<span class="st">&#39;L&#39;</span>, <span class="st">&#39;L&#39;</span>, <span class="st">&#39;L&#39;</span>, <span class="st">&#39;L&#39;</span>, <span class="st">&#39;L&#39;</span>]
A <span class="op">-&gt;</span> [<span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>]
G <span class="op">-&gt;</span> [<span class="st">&#39;G&#39;</span>, <span class="st">&#39;G&#39;</span>, <span class="st">&#39;G&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> animals <span class="op">=</span> [<span class="st">&#39;duck&#39;</span>, <span class="st">&#39;eagle&#39;</span>, <span class="st">&#39;rat&#39;</span>, <span class="st">&#39;giaffe&#39;</span>, <span class="st">&#39;bear&#39;</span>, <span class="st">&#39;bat&#39;</span>, <span class="st">&#39;dolphin&#39;</span>, <span class="st">&#39;shark&#39;</span>, <span class="st">&#39;lion&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> animals.sort(key<span class="op">=</span><span class="bu">len</span>)
<span class="op">&gt;&gt;&gt;</span> animals
[<span class="st">&#39;rat&#39;</span>, <span class="st">&#39;bat&#39;</span>, <span class="st">&#39;duck&#39;</span>, <span class="st">&#39;bear&#39;</span>, <span class="st">&#39;lion&#39;</span>, <span class="st">&#39;eagle&#39;</span>, <span class="st">&#39;shark&#39;</span>, <span class="st">&#39;giaffe&#39;</span>, <span class="st">&#39;dolphin&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> length, group <span class="kw">in</span> itertools.groupby(<span class="bu">reversed</span>(animals), <span class="bu">len</span>):
...     <span class="bu">print</span>(length, <span class="st">&#39;-&gt;&#39;</span>, <span class="bu">list</span>(group))
...
<span class="dv">7</span> <span class="op">-&gt;</span> [<span class="st">&#39;dolphin&#39;</span>]
<span class="dv">6</span> <span class="op">-&gt;</span> [<span class="st">&#39;giaffe&#39;</span>]
<span class="dv">5</span> <span class="op">-&gt;</span> [<span class="st">&#39;shark&#39;</span>, <span class="st">&#39;eagle&#39;</span>]
<span class="dv">4</span> <span class="op">-&gt;</span> [<span class="st">&#39;lion&#39;</span>, <span class="st">&#39;bear&#39;</span>, <span class="st">&#39;duck&#39;</span>]
<span class="dv">3</span> <span class="op">-&gt;</span> [<span class="st">&#39;bat&#39;</span>, <span class="st">&#39;rat&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(itertools.tee(<span class="st">&#39;ABC&#39;</span>))
[<span class="op">&lt;</span>itertools._tee <span class="bu">object</span> at <span class="bn">0x10dcfb3c8</span><span class="op">&gt;</span>, <span class="op">&lt;</span>itertools._tee <span class="bu">object</span> at <span class="bn">0x10dcfb348</span><span class="op">&gt;</span>]
<span class="op">&gt;&gt;&gt;</span> g1, g2 <span class="op">=</span> itertools.tee(<span class="st">&#39;ABC&#39;</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g1)
<span class="co">&#39;A&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g1)
<span class="co">&#39;B&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g1)
<span class="co">&#39;C&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g2)
<span class="co">&#39;A&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(g2)
<span class="co">&#39;B&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(g1)
[]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(g2)
[<span class="st">&#39;C&#39;</span>]
<span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">zip</span>(<span class="op">*</span>itertools.tee(<span class="st">&#39;ABC&#39;</span>))
... )
[(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;A&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;B&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;C&#39;</span>)]</code></pre></div>
<p><code>iter</code>函数有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值；第二个值是哨符，是一个标记值，当可调用的对象返回这个值时，触发迭代器抛出<code>StopIteration</code>异常，而不产出哨符。</p>
<p>字典为<code>to yield</code>给出了两个释义：产出和让步。对于Python生成器中的<code>yield</code>来说，这两个含义都成立。<code>yield item</code>会产出一个值，提供给<code>next(···)</code>的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用<code>next()</code>。调用方会从生成器中拉取值。</p>
<p>从语句上看，协程与生成器类似，都是定义体中包含<code>yield</code>关键字的函数。在协程中，<code>yield</code>通常出现在表达式的右边（例如，datum=yield)，可以产出值，也可以不产出——如果<code>yield</code>关键字后面没有表达式，那么生成器产出<code>None</code>。协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是<code>.send(datum)</code>方法，而不是<code>next(...)</code>。通常，调用方会把值推送给协程。</p>
<p><code>yield</code>关键字甚至还可以不接收或传出数据。不管数据如何流动，<code>yield</code>都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。</p>
<p>从根本上把<code>yield</code>视作控制流程的方式，这样就好理解协程。</p>
<p><strong>协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。</strong></p>
<p>下面是协程最简单的使用。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># 协程使用使用生成器函数定义：定义体中有yield关键字</span>
<span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> simple_coroutine():
...     <span class="bu">print</span>(<span class="st">&#39;-&gt; coroutine started&#39;</span>)
...     x <span class="op">=</span> <span class="cf">yield</span> <span class="co"># yield在表达式中使用，如果协程只需从客户那里接收数据，那么产出的值是None</span>
...     <span class="bu">print</span>(<span class="st">&#39;-&gt; coroutine received:&#39;</span>, x)
...
<span class="op">&gt;&gt;&gt;</span> my_cro <span class="op">=</span> simple_coroutine()
<span class="op">&gt;&gt;&gt;</span> my_cro <span class="co"># 与创建生成器的方式一样，调用函数得到生成器对象。</span>
<span class="op">&lt;</span>generator <span class="bu">object</span> simple_coroutine at <span class="bn">0x10dcdf7d8</span><span class="op">&gt;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(my_cro) <span class="co"># 首先要调用next(...)函数，因为生成器还没有启动，没在yield语句处暂停，所以一开始没法发送数据</span>
<span class="op">-&gt;</span> coroutine started
<span class="op">&gt;&gt;&gt;</span> my_cro.send(<span class="dv">42</span>)<span class="co"># 调用这个方法后，协程定义体中的yield表达式会计算出42；现在，协程会恢复。一直运行到下一个yield表达式，或者终止。</span>
<span class="op">-&gt;</span> coroutine received: <span class="dv">42</span>
Traceback (most recent call last): <span class="co"># 控制权流动到协程定义体的末尾，导致生成器像往常一样抛出StopIteration异常。</span>
  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span>
<span class="pp">StopIteration</span></code></pre></div>
<p>协程可以身处四个状态中的一个。当前状态可以用<code>inspect.getgeneratorstate(...)</code>函数确定，该函数会返回下述字符串中的一个。</p>
<p><code>GEN_CREATED</code></p>
<p>等待开始执行。</p>
<p><code>GEN_RUNNING</code></p>
<p>解释器正在执行。</p>
<p><code>GEN_SUSPENDED</code></p>
<p>在<code>yield</code>表达式处暂停。</p>
<p><code>GEN_CLOSED</code></p>
<p>执行结束。</p>
<p>因为<code>send</code>方法</p>
<p>因为<code>send</code>方法的参数会成为暂停的<code>yield</code>表达式的值，所以，仅当协程处于暂停状态时才能调用<code>send</code>方法。而激活协程的方法是调用<code>next(my_cro)</code>，也可以调用<code>my_cro.send(None)</code>。</p>
<p>最先调用<code>next(my_coro)</code>函数通常称为“预激”（prime）协程（即让协程向前执行到第一个<code>yield</code>表达式，准备好作为活跃的协程使用）。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> simple_coro2(a):
...     <span class="bu">print</span>(<span class="st">&#39;-&gt; Started: a=&#39;</span>, a)
...     b <span class="op">=</span> <span class="cf">yield</span> a
...     <span class="bu">print</span>(<span class="st">&#39;-&gt; Received: b=&#39;</span>, b)
...     c <span class="op">=</span> <span class="cf">yield</span> a <span class="op">+</span> b
...     <span class="bu">print</span>(<span class="st">&#39;-&gt; Received: c=&#39;</span>, c)
...
<span class="op">&gt;&gt;&gt;</span> my_coro2 <span class="op">=</span> simple_coro2(<span class="dv">14</span>)
<span class="op">&gt;&gt;&gt;</span> <span class="im">from</span> inspect <span class="im">import</span> getgeneratorstate
<span class="op">&gt;&gt;&gt;</span> getgeneratorstate(my_coro2)
<span class="co">&#39;GEN_CREATED&#39;</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(my_coro2)
<span class="op">-&gt;</span> Started: a<span class="op">=</span> <span class="dv">14</span>
<span class="dv">14</span>
<span class="op">&gt;&gt;&gt;</span> getgeneratorstate(my_coro2)
<span class="co">&#39;GEN_SUSPENDED&#39;</span>
<span class="op">&gt;&gt;&gt;</span> my_coro2.send(<span class="dv">28</span>)
<span class="op">-&gt;</span> Received: b<span class="op">=</span> <span class="dv">28</span>
<span class="dv">42</span>
<span class="op">&gt;&gt;&gt;</span> my_coro2.send(<span class="dv">99</span>)
<span class="op">-&gt;</span> Received: c<span class="op">=</span> <span class="dv">99</span>
Traceback (most recent call last):
  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span>
<span class="pp">StopIteration</span></code></pre></div>
<p>关键的一点是，协程在<code>yield</code>关键字所在的位置暂停执行。在赋值语句中，<code>=</code>右边的代码在赋值之前执行。因此，对于<code>b = yield a</code>这行代码来说，等到客户端代码再激活协程时才会设定b的值。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> averager():
    total <span class="op">=</span> <span class="fl">0.0</span>
    count <span class="op">=</span> <span class="dv">0</span>
    average <span class="op">=</span> <span class="va">None</span>
    <span class="co"># 这个无限循环表明，只要调用方不断把值发给这个协程，它就会一直接收值，然后生成结果。</span>
    <span class="co"># 仅当调用方在协程上调用.close()方法</span>
    <span class="co"># 或者没有对协程的引用而被垃圾回收程序回收时，这个协程才会终止</span>
    <span class="cf">while</span> <span class="va">True</span>: 
        <span class="co"># yield表达式用于暂停执行协程，把结果发给调用方</span>
        <span class="co"># 还用于接收调用方后面发给协程的值，恢复无限循环</span>
        term <span class="op">=</span> <span class="cf">yield</span> average
        total <span class="op">+=</span> term
        count <span class="op">+=</span> term
        average <span class="op">=</span> total<span class="op">/</span>count
        
<span class="op">&gt;&gt;&gt;</span> coro_avg <span class="op">=</span> averager() <span class="co"># 创建协程对象</span>
<span class="op">&gt;&gt;&gt;</span> <span class="bu">next</span>(coro_avg) <span class="co"># 调用next函数，预激协程</span>
<span class="op">&gt;&gt;&gt;</span> coro_avg.send(<span class="dv">10</span>)
<span class="fl">10.0</span>
<span class="op">&gt;&gt;&gt;</span> coro_avg.send(<span class="dv">12</span>)
<span class="fl">11.0</span>
<span class="op">&gt;&gt;&gt;</span> coro_avg.send(<span class="dv">30</span>)
<span class="fl">17.333333333333332</span></code></pre></div>
<p>在上述例子中，调用<code>next(coro_avg)</code>函数后，协程会向前执行到<code>yield</code>表达式，产出<code>average</code>变量的初始值——None。此时协程在<code>yield</code>表达式暂停，等到调用方发送值。</p>
<p>为了简化协程的用法，有时会使用一个预激装饰器。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> functools <span class="im">import</span> wraps

<span class="kw">def</span> coroutine(func):
    <span class="at">@wraps</span>
    <span class="co"># 把被装饰的生成器函数替换成这里的primer函数；调用primer函数时，返回预激后的生成器</span>
    <span class="kw">def</span> primer(<span class="op">*</span>args, <span class="op">**</span>kwargs):
        <span class="co"># 调用被装饰的函数，获取生成器对象</span>
        gen <span class="op">=</span> func(<span class="op">*</span>args, <span class="op">**</span>kwargs)
        <span class="co"># 预激生成器</span>
        <span class="bu">next</span>(gen)
        <span class="co"># 返回生成器</span>
        <span class="cf">return</span> gen
    <span class="cf">return</span> primer

<span class="at">@coroutine</span>
<span class="kw">def</span> averager():
    total <span class="op">=</span> <span class="dv">0</span>
    count <span class="op">=</span> <span class="dv">0</span>
    average <span class="op">=</span> <span class="va">None</span>
    <span class="cf">while</span> <span class="va">True</span>:
        term <span class="op">=</span> <span class="cf">yield</span> average
        total <span class="op">+=</span> term
        count <span class="op">+=</span> <span class="dv">1</span>
        average <span class="op">=</span> total <span class="op">/</span> count</code></pre></div>
<p>使用<code>yield from</code>句法调用协程时，会自动预激。</p>
<p>客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。</p>
<p><code>generator.throw(exc_type[, exc_value[, traceback]])</code></p>
<p>致使生成器在暂停的<code>yield</code>表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个<code>yield</code>表达式，而 产出的值会成为调用<code>generator.throw</code>方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</p>
<p><code>generator.close()</code></p>
<p>致使生成器在暂停的<code>yield</code>表达式处抛出<code>GeneratorExit</code>异常。如果生成器没有处理这里异常，或者抛出了<code>StopIteration</code>异常（通常是指运行到结尾），调用方不会报错。如果收到<code>GeneratorExit</code>异常，生成器一定不能产出值，否则解释器会抛出<code>RuntimeError</code>异常。生成器抛出的其他异常会向上冒泡，传给调用方。</p>
<p>下面举例说明<code>close</code>和<code>throw</code>方法控制协程。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DemoException(<span class="pp">Exception</span>):
    <span class="co">&quot;&quot;&quot;为这次演示定义的异常类型&quot;&quot;&quot;</span>
    
<span class="kw">def</span> demo_exc_handling():
    <span class="bu">print</span>(<span class="st">&#39;-&gt; coroutine started&#39;</span>)
    <span class="cf">while</span> <span class="va">True</span>:
        <span class="cf">try</span>:
            x <span class="op">=</span> <span class="cf">yield</span> 
        <span class="cf">except</span> DemoException: <span class="co"># </span>
            <span class="bu">print</span>(<span class="st">&#39;*** DemoException handled. Continuing&#39;</span>)
    <span class="cf">raise</span> <span class="pp">RuntimeError</span>(<span class="st">&#39;This line should never run.&#39;</span>)</code></pre></div>
<p>下面这一版<code>averager</code>协程会返回结果。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> collections <span class="im">import</span> namedtuple

Result <span class="op">=</span> namedtuple(<span class="st">&#39;Result&#39;</span>, <span class="st">&#39;count average&#39;</span>)

<span class="kw">def</span> averager():
    total <span class="op">=</span> <span class="dv">0</span>
    count <span class="op">=</span> <span class="dv">0</span>
    average <span class="op">=</span> <span class="va">None</span>
    <span class="cf">while</span> <span class="va">True</span>:
        term <span class="op">=</span> <span class="cf">yield</span>
        <span class="cf">if</span> term <span class="kw">is</span> <span class="va">None</span>:
            <span class="cf">break</span> <span class="co">#为了返回值，协程必须正常终止；因此，这一版averager中有个条件判断，以便退出累计循环</span>
        total <span class="op">+=</span> term
        count <span class="op">+=</span> <span class="dv">1</span>
        average <span class="op">=</span> total<span class="op">/</span>count
    <span class="co"># 返回一个namdetuple， 包含count和average两个字段</span>
    <span class="cf">return</span> Result(count, average)</code></pre></div>
<p>期物(<code>future</code>)是指一种对象，表示异步执行的操作。</p>
<p>首先第一版代码是依序下载。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> os
<span class="im">import</span> time
<span class="im">import</span> sys

<span class="im">import</span> requests

POP20_CC <span class="op">=</span> (<span class="st">&#39;CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR&#39;</span>).split()

BASE_URL <span class="op">=</span> <span class="st">&#39;http://flupy.org/data/flags&#39;</span>

DEST_DIR <span class="op">=</span> <span class="st">&#39;downloads/&#39;</span>

<span class="kw">def</span> save_flag(img, filename):
    path <span class="op">=</span> os.path.join(DEST_DIR, filename)
    <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">&#39;wb&#39;</span>) <span class="im">as</span> fp:
        fp.write(img)
        
<span class="kw">def</span> get_flag(cc):
    url <span class="op">=</span> <span class="st">&#39;</span><span class="sc">{}</span><span class="st">/</span><span class="sc">{cc}</span><span class="st">/</span><span class="sc">{cc}</span><span class="st">.gif&#39;</span>.<span class="bu">format</span>(BASE_URL, cc<span class="op">=</span>cc.lower())
    resp <span class="op">=</span> requests.get(url)
    <span class="cf">return</span> resp.content

<span class="kw">def</span> show(text):
    <span class="bu">print</span>(text, end<span class="op">=</span><span class="st">&#39; &#39;</span>)
    sys.stdout.flush()
    
<span class="kw">def</span> download_many(cc_list):
    <span class="cf">for</span> cc <span class="kw">in</span> <span class="bu">sorted</span>(cc_list):
        image <span class="op">=</span> get_flag(cc)
        show(cc)
        save_flag(image, cc.lower() <span class="op">+</span> <span class="st">&#39;.gif&#39;</span>)
    <span class="cf">return</span> <span class="bu">len</span>(cc_list)

<span class="kw">def</span> main(download_many):
    t0 <span class="op">=</span> time.time()
    count <span class="op">=</span> download_many(POP20_CC)
    elapsed <span class="op">=</span> time.time() <span class="op">-</span> t0
    msg <span class="op">=</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="sc">{}</span><span class="st"> flags downloaded in </span><span class="sc">{:.2f}</span><span class="st">s&#39;</span>
    <span class="bu">print</span>(msg.<span class="bu">format</span>(count, elapsed))
    
<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    main(download_mang)</code></pre></div>
<p>下面这一版是利用<code>concurrent.futures</code>模块重新实现。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> concurrent <span class="im">import</span> futures

<span class="im">from</span> flags <span class="im">import</span> save_flag, get_flag, show, main

MAX_WORKERS <span class="op">=</span> <span class="dv">20</span> <span class="co"># 设定ThreadPoolExecutor类最多使用几个线程</span>

<span class="kw">def</span> download_one(cc):
    image <span class="op">=</span> get_flag(cc)
    show(cc)
    save_flag(image, cc.lower() <span class="op">+</span> <span class="st">&#39;.gif&#39;</span>)
    <span class="cf">return</span> cc

<span class="kw">def</span> download_many(cc_list):
    <span class="co"># 设定工作的线程数量：使用允许的最大值（MAX_WORKERS）与要处理的数量之间较少的那个值</span>
    <span class="co"># 以免创建多余的线程</span>
    workers <span class="op">=</span> <span class="bu">min</span>(MAX_WORKERS, <span class="bu">len</span>(cc_list))
    <span class="co"># 使用工作的线程数实例化ThreadPoolExecutor类</span>
    <span class="co"># executor.__exit__ 方法会调用executor.shutdown(wait=True)方法</span>
    <span class="co"># 它会在所有线程都执行完毕前阻塞线程</span>
    <span class="cf">with</span> futures.ThreadPoolExecutor(workers) <span class="im">as</span> executor:
        <span class="co"># map方法的作用与内置的map函数类似，不过download_one函数会在多个线程中并发调用</span>
        <span class="co"># map方法返回一个生成器，因此可以迭代，获取各个函数返回的值</span>
        res <span class="op">=</span> executor.<span class="bu">map</span>(download_one, <span class="bu">sorted</span>(cc_list))
    <span class="co"># 返回获取的结果数量</span>
    <span class="co"># 如果有线程抛出异常，异常会在这里抛出，这与隐式调用next()函数从迭代器中获取相应的返回值一样</span>
    <span class="cf">return</span> <span class="bu">len</span>(<span class="bu">list</span>(res))

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    main(download_many)</code></pre></div>
<p>如果使用线程编程时，调度程序任何时候都能中断线程。而且必须记住保留锁，去保护程序中的重要部分，防止多步操作在执行的过程中中断，防止数据处于无效状态。</p>
<p>而协程默认会做好全方位保护，以防止中断。我们必须显式产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。想交出控制权时，可以使用<code>yield</code>或<code>yield from</code>把控制权交还调度程序。这就是能够安全地取消协程的原因：按照定义，协程只能在暂停的<code>yield</code>处取消，因此可以处理<code>CancelledError</code>异常，执行清理操作。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/28/流畅的Python-读书笔记-三/" rel="next" title="流畅的Python_读书笔记(三)">
                <i class="fa fa-chevron-left"></i> 流畅的Python_读书笔记(三)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/11/流畅的Python-读书笔记-五/" rel="prev" title="流畅的Python-读书笔记(五)">
                流畅的Python-读书笔记(五) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/pandas.jpeg"
               alt="Peter Tsung" />
          <p class="site-author-name" itemprop="name">Peter Tsung</p>
           
              <p class="site-description motion-element" itemprop="description">I Never Save Anything For The Swim Back.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Peter Tsung</span>
</div>

<!--
<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
                    TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
                            messageStyle: "none"
                                }); 
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Queue(function() {
                    var all = MathJax.Hub.getAllJax(), i;
                            for(i=0; i < all.length; i += 1) {
                                            all[i].SourceElement().parentNode.className += ' has-jax';
                                                    }
                                                        });
        </script>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

-->


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  


  <script src="/js/src/prettify.js" type="text/javascript"></script>
  <script type="text/javascript">
    $(window).load(function(){
    $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
     prettyPrint();
    })
  </script>
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
